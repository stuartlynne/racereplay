#!/usr/bin/perl 

#
# Usage wtdb hostname port [directory]
#
# Connect to hostname:port, collect data and store in:
#
#       [directory/]laps-$Venue-$Date.csv
#
# This is a persistant server. It will continue to connect to the specified
# host and collected data until stopped. 
#
# This service is reasonably robost if restarted.  Typically this will be connecting to a
# service that delivers all # current data from the timing system. A stop and restart may collect 
# and save the same data. So some care must be taken to ignore duplicate # entries in the laps data.
#
# The server is designed to close the socket and attempt to re-establish a connection if there
# is a TCP KEEPALIVE timeout. This allows the service to be robust for the following failures:
#
#       1. Network outage for more than 10 seconds
#       2. WT Active restart
#       3. Network outage with WT Active restart before network re-established.
#
# The only time that timing data will not be recorded is the following:
#
#       1. Network outage
#       2. WT Active Restart
#       3. Data collected - this data will be lost
#       4. WT Active Restart
#       5. Network re-established
#
# This is due to the simple model on the WT Active unit, the service there only replays
# the data from the current file. Restarting starts a new file. 
# 
# In practice this should not be a huge problem.
#
#
# Signals
#       1. SIGHUP - restart
#       2. SIGTERM - exit
# 
#
# 


use strict;
use warnings;

use DBI;
use CGI ':standard';

use Text::CSV;
use Getopt::Std;
use Switch;
use Scalar::Util qw(looks_like_number);
use IO::Socket;
use IO::Socket::INET;
use Socket qw(IPPROTO_TCP SOL_SOCKET SO_LINGER SO_KEEPALIVE inet_aton sockaddr_in TCP_NODELAY);
#use Socket::Linux ;
use Socket::Linux qw(TCP_NODELAY TCP_KEEPIDLE TCP_KEEPINTVL TCP_KEEPCNT);
use IO::Select;
use Time::CTime;
use Sys::Syslog qw (:standard :macros);

# WActive CSV Codes
#
my $WACTIVE_RX = 0;
my $WACTIVE_TAGID = 1;
my $WACTIVE_DATE = 2;
my $WACTIVE_WTIME_HHMMSS = 3;
my $WACTIVE_WTIME_MS = 4;
my $WACTIVE_BATT = 5;
my $WACTIVE_EVENT = 6;
my $WACTIVE_BOX = 7;
my $WACTIVE_CORR = 8;
my $WACTIVE_STIME_HHMMSS = 9;
my $WACTIVE_STIME_MS = 10;




sub usage {
    printf STDERR "Usage: wtdb [venue] | [ipaddr port]\n";
    printf STDERR "\tvenue - read WT Ative RACE CSV file on STDIN, output processed data on STDOUT\n";
    printf STDERR "\tipaddr port - connect to ipaddr:port, save in /var/racereplay/laps.*csv\n";
    exit;
}

my $VenueName = "novenue";
my $ServerMode = 0;
my $IPAddress;
my $Port;

#my $VenueName = $ARGV[0];
#shift @ARGV || die usage;

my $dbh;

sub get_active_venue {
    
    my $sql = sprintf ( "SELECT * FROM venues where ActiveFlag = '1'");
    my $sth = $dbh->prepare($sql);;
    $sth->execute() || die "Execute failed\n";
    
    my $row_ref = $sth->fetchrow_hashref;
    $sth->finish();

    unless(defined($row_ref)) {
        printf STDERR "No active venue\n";
        return "novenue";
    }

    unless(defined($row_ref->{'venue'})) {
        printf STDERR "No active venue\n";
        return "novenue";
    }
    
    return $row_ref->{'venue'};
}

sub get_venue_info {
    
    my ($active) = @_;

    my $sql = sprintf ( "SELECT * FROM venues where Venue = '%s'", $active);
    my $sth = $dbh->prepare($sql);;
    $sth->execute() || die "Execute failed\n";
    
    my $row_ref = $sth->fetchrow_hashref;
    $sth->finish();

    unless(defined($row_ref)) {
        printf STDERR "No active venue\n";
        return;
    }

    unless(defined($row_ref->{'venue'})) {
        printf STDERR "No active venue\n";
        return "novenue";
    }
    
    # return hashref
    #
    printf STDERR "Organizer: %s description %s\n", $active, $row_ref->{ 'description' };
    return $row_ref;
}

#my $Users_ref;

sub get_users_info {
    
    my ($organizer) = @_;

    my $sql = sprintf("SELECT tagid, timestamp FROM users WHERE organizer LIKE '%s' AND firstname LIKE '' AND lastname LIKE '' ", $organizer);
    my $sth = $dbh->prepare($sql);

    $sth->execute() || die "Execute failed\n";
    my $Users_ref = $sth->fetchall_hashref( 'tagid' );
    $sth->finish();

}


# ################################################################################################################### #




sub print_csv_str {

    my ($cell, $last) = @_;

    #printf STDOUT "\"%s\"", $cell;
    #if ($last) { printf STDOUT "\n"; } else { printf STDOUT ","; }

    printf FOUT "\"%s\"", $cell;
    if ($last) { 
        printf FOUT "\n"; FOUT->flush; } 
    else { 
        printf FOUT ","; }

}

sub get_ms {

    my ($xtime, $mstime) = @_;

    my @values = split(/\./,$xtime);
    return 0 unless (looks_like_number($values[0]));
    return 0 unless (looks_like_number($values[1]));
    return 0 unless (looks_like_number($values[2]));

    #printf STDERR "values: %s - %s - %s\n", $values[0], $values[1], $values[2];

    return (($values[0] * 60*60 + $values[1] * 60 + $values[2] ) * 1000 + $mstime);

}

# ################################################################################################################### #

my %LastSeen;
my $GroupStartMS = 0;
my $GroupLastMS = 0;

#my $csv = Text::CSV->new({ binary=> 1, eol => $/ });

sub process {

    my ($csv, $line, $firstflag, $count, $organizer, $distance, $mintime, $maxtime, $gaptime, $venuename) = @_;


    # ensure that we have column titles
    #
    if ($firstflag) {

        printf STDERR "firstflag: %d count: %d\n", $firstflag, $count;

        print_csv_str("timestamp", 0);  # 0
        print_csv_str("venue", 0);      # 1
        print_csv_str("boxid", 0);      # 2
        print_csv_str("eventid", 0);    # 3
        print_csv_str("rx", 0);         # 4
        print_csv_str("tagid", 0);      # 5
        print_csv_str("corr", 0);       # 6
        print_csv_str("finishms", 0);   # 7
        print_csv_str("startms", 0);    # 8
        print_csv_str("groupms", 0);    # 9
        print_csv_str("lapms", 1);      # 10
    }

    # trim the linefeed, parse the line and retrieve the fields and TAGID
    #
    chop($line);
    my $status = $csv->parse($line);
    my @fields = $csv->fields();
    return if ($#fields == 0);
    my $tagid = $fields[1];
    return if ($tagid eq "TAG_ID");


    # compute the elapsed time in milliseconds
    #
    my $MS = get_ms($fields[$WACTIVE_STIME_HHMMSS], $fields[$WACTIVE_STIME_MS]);

    my $lastMS = 0;     # previously seen MS
    my $lapMS = 0;      # laptime MS
    my $groupMS = 0;    # time from beginning of this group

    if (defined $LastSeen{$tagid}) {

        $lastMS =  $LastSeen{$tagid};
        $lapMS = $MS - $lastMS;
        $LastSeen{$tagid} = $MS;

        if ($lapMS > $maxtime) {
            #printf STDERR "%s: MS: %d - %d  = %d TOO SLOW > %d\n", $tagid, $MS, $lastMS, $lapMS, $maxtime;
            $lastMS = 0;
            $lapMS = 0;
        }
        elsif (($lapMS) < $mintime) {
            #printf STDERR "%s: MS: %d - %dd  = %d TOO FAST < %d\n", $tagid, $MS, $lastMS, $lapMS, $mintime;
            $lastMS = 0;
            $lapMS = 0;
        }
        else {
            #printf STDERR "%s: MS: %d - d %d\n", $tagid, $MS, $lastMS, $lapMS;
        }
       
    }
    else {
        #printf STDERR "%s: MS: %d FIRST\n", $tagid, $MS;
        $LastSeen{$tagid} = $MS;
    }

    # Get the elapsed time from the beginning of this group
    #
    # If there is no current group start time then use this as the start of one
    #
    unless ($GroupStartMS) {
        #printf STDERR "%s: GroupStartMS: ZERO %d\n", $tagid, $groupMS;
        $GroupStartMS = $MS;
        $GroupLastMS = $MS;
        $groupMS = 0;
    }
    # 
    # if the time from the last recorded time in the group exceeds the gaptime then reset
    #
    elsif (($MS - $GroupLastMS) > $gaptime) {
        #printf STDERR "%s: GroupStartMS: %d %d too large > %d\n", $tagid, $GroupStartMS, $MS, $gaptime;
        $GroupStartMS = $MS;
        $GroupLastMS = $MS;
        $groupMS = 0;
    }
    #
    # within the gaptime so compute the groupMS and save the last group time
    #
    else {
        $groupMS = $MS - $GroupStartMS;
        $GroupLastMS = $MS;
        #printf STDERR "%s: GroupStartMS: %d %d < gap: %d\n", $tagid, $GroupStartMS, $MS, $groupMS;
    }


    # 
    # create our timestamp
    #
    my $date = $fields[$WACTIVE_DATE];
    my $hhmmss = $fields[$WACTIVE_WTIME_HHMMSS];
    $date =~ s/\//-/g;
    #$hhmmss =~ s/\./:/g;
    my $timestamp = "$date $hhmmss";

    # 
    # dump the data fields
    #
    print_csv_str($timestamp, 0);               # 0
    print_csv_str($venuename, 0);               # 1
    print_csv_str($fields[$WACTIVE_BOX], 0);    # 2 box id
    print_csv_str($fields[$WACTIVE_EVENT], 0);  # 3 BOX
    print_csv_str($fields[$WACTIVE_RX], 0);     # 4 RX
    print_csv_str($tagid, 0);                   # 5 tag id
    print_csv_str($fields[$WACTIVE_CORR], 0);   # 6 CORR
    print_csv_str($MS, 0);                      # 7 time lap finished
    print_csv_str($lastMS, 0);                  # 8 time lap started (if available)
    print_csv_str($groupMS, 0);                 # 9 group time (from beginning of group lap)
    print_csv_str($lapMS, 1);                   # 10 lap time (if start time available)

}

my $FoutFilename = "";

sub openfout {

    my ($venuename) = @_;

    my $datestamp = strftime("%Y%m%d", localtime(time));
    my $filename = sprintf(">>lapd-%s-%s.csv", $venuename, $datestamp);


    if ($FoutFilename ne "") {
        if ($FoutFilename eq $filename) {
            return;
        }
        #printf STDERR "CLOSING %s\n", $FoutFilename;
        close FOUT;
    }

    $FoutFilename = $filename;
    printf STDERR "OPENING %s\n", $FoutFilename;

    if ($ServerMode) {
        my $loginfo = sprintf("File: %s", $filename);
        syslog('warning', $loginfo);
    }

    open (FOUT, $filename) || die "Cannot open $filename\n";

}

# ################################################################################################################### #

my $RestartFlag = 0;

sub dist2ms {
    my ($distance, $speed) = @_;

    return ($distance / $speed) *60 * 60 * 1000;
}

sub do_fileio {

    my ($csv, $venuename) = @_;

    my $Venue_ref = get_venue_info($venuename);

    my $organizer = "";
    my $distance = 0;
    my $minspeed = 0;
    my $maxspeed = 0;
    my $mintime = 0;
    my $maxtime = 0;
    my $gaptime = 0;
    if ($Venue_ref) {
        $organizer = $Venue_ref->{'organizer'};
        $distance = $Venue_ref->{'distance'};
        $minspeed = $Venue_ref->{'minspeed'};
        $maxspeed = $Venue_ref->{'maxspeed'};
        $gaptime = $Venue_ref->{'gaptime'} * 1000;
        $mintime = dist2ms($distance, $maxspeed);
        $maxtime = dist2ms($distance, $minspeed);
    }

    #printf STDERR "Venue: %s distance:%s speed: %d:%d time: %d:%d\n", $venuename, $distance, $minspeed, $maxspeed, $mintime, $maxtime;;

    open(FOUT, ">&STDOUT");
    my $count = 0;
    while (<STDIN>) {
        my $firstflag = $count == 0;
        process($csv, $_, $firstflag, $count++, $organizer, $distance, $mintime, $maxtime, $gaptime, $venuename);
        last if ($RestartFlag);
    }

}

sub do_io {

    my ($csv, $skt) = @_;

    my $venuename = get_active_venue();
    my $Venue = get_venue_info($VenueName);
    my $Venue_ref = get_venue_info($venuename);

    my $organizer = "";
    my $distance = 0;
    my $minspeed = 0;
    my $maxspeed = 0;
    my $mintime = 0;
    my $maxtime = 0;
    my $gaptime = 0;
    if ($Venue_ref) {
        $organizer = $Venue_ref->{'organizer'};
        $distance = $Venue_ref->{'distance'};
        $minspeed = $Venue_ref->{'minspeed'};
        $maxspeed = $Venue_ref->{'maxspeed'};
        $gaptime = $Venue_ref->{'gaptime'} * 1000;
        $mintime = dist2ms($distance, $maxspeed);
        $maxtime = dist2ms($distance, $minspeed);
    }

    $RestartFlag = 0;
    my $count = 0;
    while (<$skt>) {
        openfout($venuename);
        my ($ndev, $nino, $nmode, $nnlik, $nuid, $ngid, $nrdev, $nsize, $natime, $nmtime, $nctime, $nblksize, $nbloxks) = stat (FOUT);
        my $firstflag = $nsize == 0;
        process($csv, $_, $firstflag, $count++, $organizer, $distance, $mintime, $maxtime, $gaptime, $venuename);
        last if ($RestartFlag);
    }

    $FoutFilename = "";
    close(FOUT);

    my $loginfo = sprintf("Socket closed: %s %s %d", $IPAddress, $Port, $RestartFlag);
    syslog('warning', $loginfo);
    #printf STDERR "DO_IO EXITING\n";

}

# ################################################################################################################### #


my $skt;

sub sighandler {
    my ($sig) = @_;
    if ($ServerMode) {
        my $loginfo = sprintf("caught signal: %s", $sig);
        syslog('warning', $loginfo);
    }

    printf STDERR "Caught signal: %s\n", $sig;

    if ($sig eq "HUP") {
        $skt->shutdown();
        $RestartFlag = 1;
        die;
    }
    if ($sig eq "INT") {
        exit();
    }
}


# ################################################################################################################### #


# ################################################################################################################### #

#printf STDERR "ARGV count: %d\n", $#ARGV;

# venue
# servermode = 0
if ($#ARGV == 0) {
    $ServerMode = 0;
    $VenueName = $ARGV[0];
    shift @ARGV || die usage;
}
#
# ipaddress port [dir]
# servermode = 1
else {
    $ServerMode = 1;
    $IPAddress = $ARGV[0];
    shift @ARGV || die usage;
    $Port = $ARGV[0];
    shift @ARGV || die usage;
    if ($#ARGV == 0) {
        my $dir = $ARGV[0];
        mkdir ($dir);
        chdir ($dir) || die "Cannot chdir to $dir\n";
        my $loginfo = sprintf("wtactive started: %s %s %s %s", $VenueName, $IPAddress, $Port, $dir);
        syslog('warning', $loginfo);
        #printf STDERR "Chdir %s\n", $dir;
    }
    else {
        my $loginfo = sprintf("wtactive started: %s %s %s", $VenueName, $IPAddress, $Port);
        syslog('warning', $loginfo);

    }
}


#printf STDERR "ARGC: %d\n", $#ARGV;


#setlogsock('unix');
openlog($0, "ndelay,pid", "daemon");


#printf STDERR "Venue: %s\n", $VenueName;
#printf STDERR "Host: %s\n", $IPAddress;
#printf STDERR "Port: %s\n", $Port;

my $socketcount = 0;
my $Directory = "/var/racereplay";

$dbh = DBI->connect("dbi:CSV:f_dir=$Directory;csv_eol=\n;");
$dbh->{'AutoCommit'} = 1;       # CSV does not support transactions
$dbh->{'RaiseError'} = 1;
$dbh->{'csv_tables' }->{'organizers'} = {'file' => 'organizers.csv'};
$dbh->{'csv_tables' }->{'venues'} = {'file' => 'venues.csv'};
$dbh->{'csv_tables' }->{'users'} = {'file' => 'users.csv'};

my $csv = Text::CSV->new({ binary=> 1, eol => $/ });

#get_users_info();


unless ($ServerMode) {
    do_fileio($csv, $VenueName);
    exit;
}

#
# Repeat forever....
#
# 1. Open a socket to connect to server.
# 2. Set socket options to enable TCP KEEPALIVE
# 3. Process until socket closes.
# 4. sleep
#
while(1) {

    # connect to server
    #
    $skt = IO::Socket::INET->new(
            'PeerAddr' => $IPAddress, 
            'PeerPort' => $Port, 
            'Proto' => 'tcp');

    # did we get a connection?
    #
    unless (defined($skt)) {
        my $loginfo = sprintf("Socket not created: %s %s", $IPAddress, $Port);
        syslog('warning', $loginfo);
        #printf STDERR "Socket not created! %s %s\n", $IPAddress, $Port;
        sleep(5);
        next;
    }

    my $loginfo = sprintf("Socket open: %s %s", $IPAddress, $Port);
    syslog('warning', $loginfo);

    # Set socket options to ensure we get TCP KEEPALIVE enabled
    # N.B. these are linux specific options
    #
    my $ierr = setsockopt($skt, SOL_SOCKET, SO_KEEPALIVE, 1);
    unless ($ierr) {
        printf STDERR "setsockopt SOL_KEEPALIVE: %d\n", $ierr;
    }
    #setsockopt($skt, IPPROTO_TCP, TCP_NODELAY, 1);
    setsockopt($skt, SOL_SOCKET, SO_LINGER, 0);
    setsockopt($skt, IPPROTO_TCP, TCP_KEEPIDLE, 10);
    setsockopt($skt, IPPROTO_TCP, TCP_KEEPINTVL, 5);
    setsockopt($skt, IPPROTO_TCP, TCP_KEEPCNT, 5);


    # use an eval so that we can use die
    # in signal handler to close socket in pending read.
    #
    eval {
        $SIG{ 'INT' } = 'sighandler';
        $SIG{ 'HUP' } = 'sighandler';

        # process data on this socket
        #
        do_io($csv, $skt);
    };
    #printf STDERR "RESTART\n";

    # short delay to prevent runaway connecting
    #
    sleep(5);

}

